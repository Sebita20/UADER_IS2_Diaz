Imagina que estás desarrollando un sistema para una cafetería que maneja una amplia variedad de bebidas, como café, té, refrescos, batidos, etc. Cada una de estas bebidas puede tener varias variantes, como tamaño (pequeño, mediano, grande), tipo de leche (entera, descremada, sin lactosa), saborizantes adicionales, temperatura, etc.
En este escenario, el patrón Flyweight podría ser útil para manejar las propiedades compartidas entre las diferentes variantes de bebidas. Por ejemplo, podrías tener una clase Bebida que actúe como una interfaz para todas las bebidas, y luego implementar clases concretas como Café, Té, Refresco, etc., que implementen esta interfaz.
Luego, podrías tener una fábrica de bebidas que administre todas las instancias de bebidas creadas. El patrón Flyweight se aplicaría aquí para compartir propiedades comunes entre las variantes de bebidas, como el nombre de la bebida, el precio base, la disponibilidad de ingredientes comunes, etc.
Por ejemplo, si tienes un café con leche y un café solo, ambas variantes de café compartirían la misma información básica sobre el café (como su nombre, precio base, ingredientes comunes como el café mismo), mientras que las propiedades únicas como el tamaño y el tipo de leche se almacenarían fuera del objeto flyweight y se pasarían como parámetros o se almacenarían por separado.
Este enfoque puede ayudar a reducir la sobrecarga de memoria al evitar la creación de múltiples instancias de objetos con información compartida y, en su lugar, compartir esa información entre las diferentes variantes de bebidas.